[[xsd_core_abstract_process]]
=== Requirements Class: Core Abstract Process Schema
include::requirements/xml/coreProcess/requirements_class.adoc[]

XML Schema elements and types defined in the “core.xsd” schema file implements all classes defined in the “Core Abstract Process” UML package.

include::requirements/xml/coreProcess/requirement1.adoc[]     

==== General XML Principles

This section lists common requirements associated to the XML encoding rules used in the context of this standard. As mentioned above, the normative XML schemas in this standard have been generated by strictly following UML to XML encoding rules, such that the schemas are the exact image of the UML models. The same encoding principles shall be used by all extensions of this standard.

===== XML Encoding Conventions

The rules used to encode the SensorML models into an XML Schema are similar to those used to derive GML application schemas and defined in ISO 19136. Most extensions to these rules were defined and implemented within the OGC SWE Common Data v2.0 standard and have been defined to allow the following.

* Use of "soft-typed" properties. These properties are encoded as XML elements with a generic element name but provide a "name" attribute for further disambiguation.
* Encoding of certain properties as XML attributes. This type of encoding adds to the "element-only" rules defined by ISO 19136. It is restricted to properties with a primitive type and indicated by a new tagged value in the UML model.
* Use of a new abstract base type. A custom base type called "AbstractSWEType" is used for all complex types.

Following ISO 19136 encoding rules, each UML class with a _Type_ or _DataType_ stereotype, or no stereotype at all, is implemented in the schema as a global XML complex type with a corresponding global XML element (called object element). Each of these elements has the same name as the UML class (i.e., always UpperCamelCase) and the name of the associated complex type is a concatenation of this name and the word "Type".

Each UML class attribute is implemented either as a global complex type and a corresponding local element (called property element), or as an XML attribute. Each property complex type is given a name composed of the UML attribute name (always lowerCamelCase) and the words "PropertyType". The element is defined locally within the complex type representing the class carrying the attribute and named exactly like the attribute in UML (i.e., no global elements are created for class attributes). Class associations are implemented similarly except they cannot be implemented as an XML attributes.

===== IDs and Linkable Properties

The schemas defined in this standard make extensive use of "xlink" features to support hypertext referencing in XML. This allows most property elements to reference content either internally or externally to the instance document, instead of including this content inline. This is supported by extensive use of the "id" attribute (of type xs:ID) on most object elements, and of the "swe:AssociationAttributeGroup" attribute group, on most property elements.

According to settings in the SensorML models, values for properties can be provided inline, by reference, or by either method.

In properties that support "xlink" attributes, one can usually choose to define that property value inline, as in:

[source,xml]
====
  <swe:field>
     <swe:Quantity id="TEMP" … />
  </swe:field>
====

One can then reference an object within the same document by its ID:

[source,xml]
====
<swe:field xlink:href="#TEMP"/>
====

An object within an external document can also be referenced by including the full URI:

[source,xml]
====
<swe:field xlink:href="http://www.my.com/fields.xml#TEMP"/>
====

Typically, "xlink" references will be specified as resolvable URLs. It is required that the property has either the "xlink:href" attribute set or contain an inline value, even though this cannot be enforced by XML schema.

include::requirements/xml/coreProcess/requirement2.adoc[]


As later specified, further requirements may be placed on the use of objects reference by xlink. This includes in some case, the use of both xlink:href to provide a resolvable link to the object’s description as well as the use of an xlink:title to provide the uniqueID of the object. Particular properties may also require the application of xlink:role or xlink:arcrole to provide the absolute and relative role of the object, respectively.

===== Extensibility Points

The SensorML schemas define extensibility points that can be used to insert ad-hoc XML content that is not specified by this standard. This is done via optional “extension” element of type “xs:anyType” in the base abstract complex type “AbstractSWEType”. Since all object types defined in this standard derive from this base type, extensions can be added for many properties in a SensorML instance.

This mechanism allows for a “laxist” way of including extended content in XML instances as the extended content is by default ignored by the validator. However, it is also possible to formally validate extended content by writing an XML schema for the extension and feeding it to the validator via the “xsi:schemaLocation” attribute in all instances using the extension.

The recommended way of extending the XML schema of this standard is to define new properties on existing objects by inserting them in an “extension” slot. Additionally this should be done in a way that these new properties can be safely ignored by an implementation that is not compatible with a given extension. However, it should be recognized that defining new XML object elements (such as new data component objects) rather than new properties will greatly reduce forward compatibility of implementations compliant to this standard with XML instances containing extensions of this standard.

In any case, all extensions of the XML schema described in this standard shall be defined in a new namespace (other than the namespaces used by this standard and its dependencies) in order to allow easy detection of extensions by implementations.

include::requirements/xml/coreProcess/requirement3.adoc[]

Extensions are not allowed to change the meaning or behavior of elements and types defined by this standard in any way (in this case, new classes or properties shall me defined). This guarantees that implementations that have no knowledge of an extension can still properly use XML instances containing these extensions.

include::requirements/xml/coreProcess/requirement4.adoc[]

The execution of the process should not depend on information contained within an extension. Data values required for process execution must be provided within the input, output, and parameter properties, and within the SensorML and SWE Common Data namespace elements (i.e., sml and swe, respectively), and cannot exclusively be contained in the extension classes.

include::requirements/xml/coreProcess/requirement5.adoc[]

Note that extension points are also supported by the SWE Common Data specification such that community-specific XML elements can be added to any property value that uses a SWE Common data type element as its value. Common anticipated applications of property-specific extension points include security tagging of individual properties and community-specific quality control characterization of property values.

==== General XSD Dependencies and XML Heading

 

The header for all specified schema provides namespaces and dependencies. The header for core processes below specifices the namespaces and dependent schema for “sml”, “swe”, “gml”, “gco”, and “gmd”.

[source,xml]
====
<schema xmlns="http://www.w3.org/2001/XMLSchema" xmlns:xml="http://www.w3.org/XML/1998/namespace" xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:sml="http://www.opengis.net/SensorML/2.1" xmlns:gml="http://www.opengis.net/gml/3.2" xmlns:swe="http://www.opengis.net/swe/2.0" targetNamespace="http://www.opengis.net/SensorML/2.1" elementFormDefault="qualified" attributeFormDefault="unqualified">
     <annotation>
          <documentation>The core elements of an abstract process from which all major elements of SensorML are derived.
          </documentation>
     </annotation>
     <import namespace="http://www.isotc211.org/2005/gmd" 
             schemaLocation="http://schemas.opengis.net/iso/19139/20070417/gmd/gmd.xsd"/>
     <import namespace="http://www.isotc211.org/2005/gco"
             schemaLocation="http://schemas.opengis.net/iso/19139/20070417/gco/gco.xsd"/>
     <import namespace="http://www.opengis.net/gml/3.2"
             schemaLocation="http://schemas.opengis.net/gml/3.2.1/gml.xsd"/>
     <import namespace="http://www.opengis.net/swe/2.0"
            schemaLocation="http://schemas.opengis.net/sweCommon/2.0/swe.xsd"/>
     <import namespace="http://www.w3.org/XML/1998/namespace"
            schemaLocation="http://www.w3.org/2001/xml.xsd"/>
====

 

include::requirements/xml/coreProcess/requirement6.adoc[]

include::requirements/xml/coreProcess/requirement7.adoc[]

Several base abstract types are defined in the SWE Common Data standard are used for derivation of elements within this SensorML specification. These are defined in the “swe” namespace and defined in: http://schemas.opengis.net/sweCommon/2.0/basic_types.xsd

These basic types are used as base substitution groups for all global XML elements defined in this standard. Below are XML schema snippets for the “AbstractSWE”, “AbstractSWEIdentifiable” and “AbstractSWEValue” elements and corresponding complex types:

[source,xml]
====
     <element name="AbstractSWE" type="swe:AbstractSWEType" abstract="true">
          <annotation>
               <documentation>Base substitution groups for all SWE Common objects other than value objects
               </documentation>
          </annotation>
     </element>
 
     <complexType name="AbstractSWEType">
          <sequence>
               <element name="extension" type="anyType" minOccurs="0" maxOccurs="unbounded">
                    <annotation>
                         <documentation>Extension slot for future extensions to this standard.
                         </documentation>
                    </annotation>
               </element>
          </sequence>
          <attribute name="id" type="ID" use="optional"/>
     </complexType>
====

 

The “AbstractSWE” complex type is the base for all derived complex types defined in this standard. It defines a first extension mechanism as an optional “extension” element that allows for any extended element content (in a namespace other than the SWE Common Data Model namespace). It also has an optional “id” attribute allowing referencing the object that derives from it.

[source,xml]
====
     <element name="AbstractSWEIdentifiable" type="swe:AbstractSWEIdentifiableType" abstract="true"
          substitutionGroup="swe:AbstractSWE">
          <annotation>
               <documentation> Base substitution groups for all SWE Common objects with identification metadata
               </documentation>
          </annotation>
     </element>
 
     <complexType name="AbstractSWEIdentifiableType">
          <complexContent>
               <extension base="swe:AbstractSWEType">
                    <sequence>
                         <element name="identifier" type="anyURI" minOccurs="0">
                              <annotation>
                                   <documentation>Unique identifier of the data component. It can be used to globally identify a particular component of the dataset, a process input/output or a universal constant
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="label" type="string" minOccurs="0">
                              <annotation>
                                   <documentation>Textual label for the data component . This is often used for displaying a human readable name for a dataset field or a process input/output
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="description" type="string" minOccurs="0">
                              <annotation>
                                   <documentation>Textual description (i.e., human readable) of the data component usually used to clarify its nature
                                   </documentation>
                              </annotation>
                         </element>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
====

The “AbstractSWEIdentifiable” complex type derives from “AbstractSWE” and adds three identification elements. These elements are to be used as described in the UML section of this standard.

Based on these dependencies, an example header for a typical SensorML instance is given below:

[source,xml]
====
<?xml version=“1.0” encoding=“UTF-8”?>
<sml:PhysicalSystem gml:id="DAVIS_PRO_VANTAGE2"
   xmlns:sml="http://www.opengis.net/SensorML/2.1"
   xmlns:swe="http://www.opengis.net/swe/2.0"
   xmlns:gml="http://www.opengis.net/gml/3.2"
   xmlns:gmd="http://www.isotc211.org/2005/gmd"
   xmlns:gco="http://www.isotc211.org/2005/gco"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xsi:schemaLocation="http://www.opengis.net/SensorML/2.1 http://schemas.opengis.net/SensorML/2.1/sensorML.xsd">
==== 

==== DescribedObject Properties

The DescribedObject element is an XML Schema implementation of the UML classes defined in clause 7.2.2. DescribedObject is the base class for all process objects defined in this standard. DescribedObject is derived from gml:AbstractFeature. In essence it provides a common set of metadata for a general feature. It is particularly suited for processes and functional devices, as later described in this specification.

The XML snippet for the DescribedObject element and its corresponding complex types is shown below:

[source,xml]
====
<element name="DescribedObject" type="sml:DescribedObjectType" abstract="true" substitutionGroup="gml:AbstractFeature">
     <annotation>
          <documentation>A feature with generic metadata which further clarifies the object and supports object discovery.
          </documentation>
     </annotation>
</element>
<complexType name="DescribedObjectType" abstract="true">
          <complexContent>
               <extension base="gml:AbstractFeatureType">
                    <sequence>
                         <element name="extension" type="anyType" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>A property that allows one to extend a document using a schema in a different namespace from the current schema.
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="keywords" type="sml:KeywordListPropertyType" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>Short keywords describing the context of this document to aid in discovery.
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="identification" type="sml:IdentifierListPropertyType" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>Identifiers useful for discovery of the process (e.g., short name, mission id, wing id, serial number, etc.)
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="classification" type="sml:ClassifierListPropertyType" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>Classifiers useful for discovery of the process (e.g., process type, sensor type, intended application, etc.)
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="validTime" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>The time instance or time range during which this instance description is valid.
                                   </documentation>
                              </annotation>
                              <complexType>
                                   <sequence>
                                        <group ref="sml:TimeInstantOrPeriod"/>
                                   </sequence>
                              </complexType>
                         </element>
                         <element name="securityConstraints" type="anyType" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>Overall security tagging of process description; individual tagging of properties can be done using extension element.
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="legalConstraints" type="gmd:MD_LegalConstraints_PropertyType" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>Legal constraints applied to this description (e.g., copyrights, legal use, etc.)
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="characteristics" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>Useful properties of this process that do not further qualify the output values (e.g., component dimensions, battery life,operational limits, etc).
                                   </documentation>
                              </annotation>
                              <complexType>
                                   <complexContent>
                                        <extension base="sml:CharacteristicListPropertyType">
                                             <attribute name="name" type="NCName" use="required"/>
                                        </extension>
                                   </complexContent>
                              </complexType>
                         </element>
                         <element name="capabilities" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>Properties that further clarify or quantify the output of the process (e.g., dynamic range, sensitivity, threshold, etc.). These can assist in the discovery of processes that meet particular requirements.
                                   </documentation>
                              </annotation>
                              <complexType>
                                   <complexContent>
                                        <extension base="sml:CapabilityListPropertyType">
                                             <attribute name="name" type="NCName" use="required"/>
                                        </extension>
                                   </complexContent>
                              </complexType>
                         </element>
                         <element name="contacts" type="sml:ContactListPropertyType" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>Persons or responsible parties that are relevant to this process (e.g., designer, manufacturer, expert, etc.)
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="documentation" type="sml:DocumentListPropertyType" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>Additional external online documentation of relevance to this process (e.g., user’s guides, product manuals, specification sheets, images, technical papers, etc.)
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="history" type="sml:EventListPropertyType" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>A collection of time-tagged events relevant to this process.
                                   </documentation>
                              </annotation>
                         </element>
                    </sequence>
                    <attribute ref="xml:lang" use="optional">
                         <annotation>
                              <documentation>A tag that identifies the language (e.g., english, french, etc.) for the overall document using a two-letters code as defined by ISO 639-1.
                              </documentation>
                         </annotation>
                    </attribute>
               </extension>
          </complexContent>
     </complexType>
====

Most properties in DescribedObject are optional, thereby allowing the description to be as small or as robust as one desires.

All property elements in DescribedObject are of type DescribedObjectPropertyType which supports the ability to reference the value of the property externally through xlink:href or provide the value inline.

[source,xml]
====
     <complexType name="DescribedObjectPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:DescribedObject"/>
          </sequence>
          <attributeGroup ref="gml:AssociationAttributeGroup"/>
          <attributeGroup ref="gml:OwnershipAttributeGroup"/>
     </complexType>
==== 

Additionally, most property values in DescribedObject are of type AbstractMetadataListType, which supports a list structure along with identification and definition properties.

[source,xml]
====
     <element name="AbstractMetadataList" type="sml:AbstractMetadataListType"
          substitutionGroup="swe:AbstractSWEIdentifiable"/>
 
     <complexType name="AbstractMetadataListType">
          <complexContent>
               <extension base="swe:AbstractSWEIdentifiableType">
                    <attribute name="definition" type="anyURI" use="optional"/>
               </extension>
          </complexContent>
     </complexType>
     <complexType name="AbstractMetadataListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:AbstractMetadataList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
====

===== Description Property

The description property is inherited from gml:AbstractFeature and provides a textual description for the feature.

An example of a description is given below:

[source,xml]
====
   <gml:description>Thermometer on the window of the Cass Building, Room 315</gml:description>
====

===== Name Property

The name property is inherited from gml:AbstractFeature and provides a common name for the feature.

An example of the name property is given below:

[source,xml]
====
  <gml:name>Health Physics Instruments 2070 Gamma Detector</gml:name>
====

 
===== Unique Identifier

This specification reserves the gml:identifier, inherited from gml:AbstractFeature, as a means of providing a unique identifier for the DescribedObject. This unique identifier should be referenced in any other specification that involves this object, thereby providing a means of searching for all references to this object.

include::requirements/xml/coreProcess/requirement8.adoc[]

The value of the gml:identifier can be a URI (e.g., URL or URN) or a series of string characters that uniquely identify the object. An example of a globally unique identifier for a weather station is given below:

[source,xml]
====
   <gml:identifier codeSpace="uid">urn:icd:stations:FR8766</gml:identifier>
   <gml:identifier codeSpace="uid">38a7s8f9d55</gml:identifier>
====
 
===== Keywords

The keyword property and the KeywordList element are XML Schema implementations of the UML classes defined in clause 7.2.2.2.

The XML snippet for the KeywordList element and its corresponding complex types is shown below:

[source,xml]
====
     <element name="KeywordList" type="sml:KeywordListType" substitutionGroup="sml:AbstractMetadataList"/>
 
     <complexType name="KeywordListType">
          <complexContent>
               <extension base="sml:AbstractMetadataListType">
                    <sequence>
                         <element name="codeSpace" type="swe:Reference" minOccurs="0" maxOccurs="1"/>
                         <element name="keyword" type="string" minOccurs="1" maxOccurs="unbounded"/>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
     <complexType name="KeywordListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:KeywordList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
==== 

The KeywordList element includes an optional codespace attribute that shall reference an external dictionary or keyword list that includes all possible keyword entries. An example of a keyword list without a codespace defined is shown below:

[source,xml]
====
     <keywords>
          <KeywordList>
               <keyword>weather station</keyword>
               <keyword>precipitation</keyword>
               <keyword>wind speed</keyword>
               <keyword>temperature</keyword>
          </KeywordList>
     </keywords>
====

 

An example of a keyword list with codespace is shown below:

[source,xml]
====
     <keywords>
          <KeywordList codespace="http://myAuthoritativeDomain.org/def/myKeywordList">
               <keyword>weather station</keyword>
               <keyword>precipitation</keyword>
               <keyword>wind speed</keyword>
               <keyword>temperature</keyword>
          </KeywordList>
     </keywords>
====
 
===== Identifiers

The IdentifierList and the Term elements are XML Schema implementations of the UML classes defined in clause 7.2.2.3. The identifier property of the IdentifierList takes a Term as its value. The Term element has an optional definition attribute that shall reference a resolvable definition of the term within an online dictionary or ontology.

The XML snippets for the IdentifierList and Term elements and their corresponding complex types are shown below:

_Term:_

[source,xml]
====
     <element name="Term" type="sml:TermType" substitutionGroup="swe:AbstractSWE"/>
 
     <complexType name="TermType">
          <complexContent>
               <extension base="swe:AbstractSWEType">
                    <sequence>
                         <element name="label" type="string"/>
                         <element name="codeSpace" type="swe:Reference" minOccurs="0" maxOccurs="1"/>
                         <element name="value" type="string"/>
                    </sequence>
                    <attribute name="definition" type="anyURI" use="optional"/>
               </extension>
          </complexContent>
     </complexType>
     <complexType name="TermPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:Term"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
====

_IdentifierList:_

[source,xml]
====
     <element name="IdentifierList" type="sml:IdentifierListType" substitutionGroup="sml:AbstractMetadataList"/>
 
     <complexType name="IdentifierListType">
          <complexContent>
               <extension base="sml:AbstractMetadataListType">
                    <sequence>
                         <element name="identifier" minOccurs="1" maxOccurs="unbounded">
                              <complexType>
                                   <sequence>
                                        <element ref="sml:Term"/>
                                   </sequence>
                              </complexType>
                         </element>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="IdentifierListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:IdentifierList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
====

An example of an identifier list is shown below:

[source,xml]
====
<sml:identification>
      <sml:IdentifierList>
         <sml:identifier>
            <sml:Term definition="http://sensorML.com/def/property/ShortName">
               <sml:label>Short Name</sml:label>
               <sml:value>Thermometer FR8766</sml:value>
            </sml:Term>
         </sml:identifier>
         <sml:identifier>
            <sml:Term definition="http://sensorML.com/def/property/Manufacturer">
               <sml:label>Manufacturer Name</sml:label>
               <sml:value>ACME Inc</sml:value>
            </sml:Term>
         </sml:identifier>
         <sml:identifier>
            <sml:Term definition="http://sensorML.com/def/property/ModelNumber">
               <sml:label>Manufacturer Model</sml:label>
               <sml:value>T911</sml:value>
            </sml:Term>
         </sml:identifier>
         <sml:identifier>
            <sml:Term definition=" http://sensorML.com/def/property/SerialNumber">
               <sml:label>Serial Number</sml:label>
               <sml:value>FT5743456566-997</sml:value>
            </sml:Term>
         </sml:identifier>
      </sml:IdentifierList>
   </sml:identification>
====

 
===== Classifiers

The ClassifierList is an XML Schema implementations of the UML classes defined in clause 7.2.2.4. The classifier property of the ClassifierList takes a Term as its value.

The XML snippet for the ClassifierList element and its corresponding complex types is shown below:

[source,xml]
====
     <element name="ClassifierList" type="sml:ClassifierListType" substitutionGroup="sml:AbstractMetadataList"/>
 
     <complexType name="ClassifierListType">
          <complexContent>
               <extension base="sml:AbstractMetadataListType">
                    <sequence>
                         <element name="classifier" minOccurs="1" maxOccurs="unbounded">
                              <complexType>
                                   <sequence>
                                        <element ref="sml:Term"/>
                                   </sequence>
                              </complexType>
                         </element>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="ClassifierListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:ClassifierList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
====

An example of a classifier list is shown below:

[source,xml]
====
    <sml:classification>
      <sml:ClassifierList>
         <sml:classifier>
            <sml:Term definition="http://sensorML.com/def/property/SensorType">
               <sml:label>Sensor Type</sml:label>
               <sml:value>Weather Station</sml:value>
            </sml:Term>
         </sml:classifier>
              <sml:classifier>
            <sml:Term definition="http://sensorML.com/def/property/IntendedApplication">
               <sml:label>Intended Application</sml:label>
               <sml:value>Weather</sml:value>
            </sml:Term>
         </sml:classifier>
      </sml:ClassifierList>
   </sml:classification>
====
 
===== Security Constraints

The securityConstraints property provides an overall security tagging for the overall document. Typically if any part of a document is classified as Secret, for instance, then the entire document is tagged as Secret.

Because various nations and other entities may have developed their own XML schema for supporting security tagging, the value of the securityConstraints property is provide as xs:any. Thus, like the extension property, the value of the securityConstraint property can be any XML, but this XML must be defined in a namespace other than those used in this standard.

include::requirements/xml/coreProcess/requirement9.adoc[]

===== Note on Security Tagging Individual Properties

It is often required or desireable that security tagging exists not only for the entire document but for individual property values as well. SensorML supports tagging of individual property values and lists through the extension property that is inherited by all elements derived from AbstractSWEType and AbstractSWEIdentifiableType.

include::requirements/xml/coreProcess/requirement10.adoc[]

===== Valid Time Constraints

The validTime element is an XML Schema implementation of the UML class defined in clause 7.2.2.6.

The XML Schema snippet from DescribedObject that pertains to the validTime property is given below.  The validTime property takes either a GML TimePeriod or TimeInstant as its value.

[source,xml]
====
     <element name="validTime" minOccurs="0" maxOccurs="unbounded">
          <annotation>
               <documentation>The time instance or time range during which this instance description is valid.
               </documentation>
          </annotation>
          <complexType>
               <sequence>
                    <group ref="sml:TimeInstantOrPeriod"/>
               </sequence>
          </complexType>
     </element>
 
     <group name="TimeInstantOrPeriod">
          <annotation>
               <documentation>Either a Time Instant or Time Period
               </documentation>
          </annotation>
          <choice>
               <element ref="gml:TimePeriod"/>
               <element ref="gml:TimeInstant"/>
          </choice>
     </group>
 
     <complexType name="TimeInstantOrPeriodPropertyType">
          <sequence minOccurs="0">
               <group ref="sml:TimeInstantOrPeriod"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
==== 

An example of the valid time being given by a TimePeriod is shown below:

[source,xml]
====
     <validTime>
          <gml:TimePeriod gml:id="deploymentDates">
               <gml:beginPosition>2009-01-01T14:00:00Z</gml:beginPosition>
               <gml:endPosition>2013-12-31T08:20:00Z</gml:endPosition>
          </gml:TimePeriod>
     </validTime>
====

 
===== Legal Constraints

The legalConstraints element is an XML Schema implementation of the UML class defined in clause 7.2.2.7.

The XML Schema snippet from DescribedObject that pertains to the legalConstraints property is given below.  The legalConstraints property takes an ISO 19115 MD_LegalConstraints element as its value, which is encoded according to ISO19139 schema.

[source,xml]
====
     <element name="legalConstraints" type="gmd:MD_LegalConstraints_PropertyType"
minOccurs="0" maxOccurs="unbounded">
          <annotation>
               <documentation>Legal constraints applied to this description (e.g., copyrights, legal use, etc.)
</documentation>
          </annotation>
     </element>
==== 

An example of legalConstraints is provided below:

[source,xml]
====
   <sml:legalConstraints>
          <gmd:MD_LegalConstraints>
                <gmd:useLimitation>
                    <gco:CharacterString>
                    Disclaimer - While every effort has been made to ensure that the data from this sensor
                    is accurate and reliable within the limits of the current state of the art, we cannot assume
                    liability for any damages caused by any errors or omissions in the data, nor as a result of
                    the failure of the data to function on a particular system. We makes no warranty, expressed
                    or implied, nor does the fact of distribution constitute such a warranty.
                    </gco:CharacterString>
               </gmd:useLimitation>
          </gmd:MD_LegalConstraints>
   </sml:legalConstraints>
====

 
===== Capabilities

The capabilities property and the CapabilitiesList element are XML Schema implementations of the UML classes defined in clause 7.2.2.9. The capabilities property takes a CapabilitiesList as its value. The CapabilitiesList member property accepts any SWE Common data component as its value.

The XML snippet for the CapabilitiesList element and its corresponding complex types is shown below:

[source,xml]
====
     <element name="CapabilityList" type="sml:CapabilityListType" substitutionGroup="sml:AbstractMetadataList"/>
 
     <complexType name="CapabilityListType">
          <complexContent>
               <extension base="sml:AbstractMetadataListType">
                    <sequence>
                         <element name="capability" minOccurs="1" maxOccurs="unbounded">
                              <complexType>
                                   <complexContent>
                                        <extension base="swe:AbstractDataComponentPropertyType">
                                             <attribute name="name" type="NCName" use="required"/>
                                        </extension>
                                   </complexContent>
                              </complexType>
                         </element>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="CapabilityListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:CapabilityList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
==== 

Thus capabilities can be described using SWE Common simple types, such as Quantity, Count, Boolean, Category, Text, and Time as well as be aggregate types such as DataRecord, DataArray, Vector, or Matrix.

An example of capabilities is given below:

[source,xml]
====
   <sml:capabilities>
      <sml:CapabilityList>
         <sml:capability name="measurementProperties">
            <swe:DataRecord definition="http://sensorML.com/def/property/measurementProperties">
               <swe:label>Measurement Properties</swe:label>
               <swe:field name="RadiationRange">
     <swe:QuantityRange definition="http://sensorML.com/def/property/radiationLevel">
        <swe:uom code="R/h"/>
        <swe:value>0 30</swe:value>
     </swe:QuantityRange>
               </swe:field>
               <swe:field name="Sensitivitity">
     <swe:Quantity definition="http://sensorML.com/def/property/radiationSensitivity">
        <swe:uom code="{tot}/uR"/>
        <swe:value>1</swe:value>
     </swe:Quantity>
               </swe:field>
               <swe:field name="SamplePeriod">
     <swe:Quantity definition="http://sensorML.com/def/property/samplePeriod">
        <swe:uom code="s"/>
        <swe:value>1</swe:value>
     </swe:Quantity>
               </swe:field>
               <swe:field name="MeasurementOutputTime">
     <swe:Quantity definition="http://sensorML.com/def/property/outputPeriod">
        <swe:uom code="s"/>
        <swe:value>450</swe:value>
     </swe:Quantity>
               </swe:field>
            </swe:DataRecord>           
         </sml:capability>
      </sml:CapabilityList> 
 </sml:capabilities>
====

 
===== Characteristics

The characteristics property and the CharacteristicsList element are XML Schema implementations of the UML classes defined in clause 7.2.2.9. The characteristics property takes a CharacteristicsList as its value. The CharacteristicsList member property accepts any SWE Common data component as its value.

The XML snippet for the CharacteristicsList element and its corresponding complex types is shown below:

[source,xml]
====
<element name="CharacteristicList" type="sml:CharacteristicListType"
           substitutionGroup="sml:AbstractMetadataList"/>
 
     <complexType name="CharacteristicListType">
          <complexContent>
               <extension base="sml:AbstractMetadataListType">
                    <sequence>
                         <element name="characteristic" minOccurs="1" maxOccurs="unbounded">
                              <complexType>
                                   <complexContent>
                                        <extension base="swe:AbstractDataComponentPropertyType">
                                             <attribute name="name" type="NCName" use="required"/>
                                        </extension>
                                   </complexContent>
                              </complexType>
                         </element>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="CharacteristicListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:CharacteristicList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
====

Thus characteristics can be described using SWE Common simple types, such as Quantity, Count, Boolean, Category, Text, and Time as well as be aggregate types such as DataRecord, DataArray, Vector, or Matrix.

An example of characteristics that groups like properties in data records is given below:

[source,xml]
====
     <sml:characteristics name="generalProperties">
          <sml:CharacteristicList>
 
               <sml:characteristic name="physicalProperties">
                    <swe:DataRecord definition="http://sensorML.com/def/property/physicalProperties">
                         <swe:label>Physical Properties</swe:label>
                         <swe:field name="PhysicalProperties">
                              <swe:DataRecord>
                                   <swe:field name="Weight">
                                        <swe:Quantity definition="http://sensorML.com/def/property/weight">
                                             <swe:uom code="oz"/>
                                             <swe:value>10</swe:value>
                                        </swe:Quantity>
                                   </swe:field>
                                   <swe:field name="Length">
                                        <swe:Quantity definition="http://sensorML.com/def/property/length">
                                             <swe:uom code="in"/>
                                             <swe:value>4.5</swe:value>
                                        </swe:Quantity>
                                   </swe:field>
                                   <swe:field name="Width">
                                        <swe:Quantity definition="http://sensorML.com/def/property/width">
                                             <swe:uom code="in"/>
                                             <swe:value>2.5</swe:value>
                                        </swe:Quantity>
                                   </swe:field>
                                   <swe:field name="Height">
                                        <swe:Quantity definition="http://sensorML.com/def/property/height">
                                             <swe:uom code="in"/>
                                             <swe:value>1.4</swe:value>
                                        </swe:Quantity>
                                   </swe:field>
                                   <swe:field name="CasingMaterial">
                                        <swe:Category definition="http://sensorML.com/def/property/material">
                                             <swe:value>Aluminum</swe:value>
                                        </swe:Category>
                                   </swe:field>
                              </swe:DataRecord>
                         </swe:field>
                    </swe:DataRecord>
               </sml:characteristic>
 
               <sml:characteristic name="electricalRequirements">
                    <swe:DataRecord definition="http://sensorML.com/def/property/powerRequirement">
                         <swe:label>Electrical Requirements</swe:label>
                         <swe:field name="voltage">
                              <swe:QuantityRange definition="http://sensorML.com/def/property/voltage">
                                   <swe:uom code="V"/>
                                   <swe:value>8 12</swe:value>
                              </swe:QuantityRange>
                         </swe:field>
                         <swe:field name="CurrentType">
                              <swe:Category definition="http://sensorML.com/def/property/electricalCurrentType">
                                   <swe:value>DC</swe:value>
                              </swe:Category>
                         </swe:field>
                         <swe:field name="AmpRange">
                              <swe:QuantityRange definition="http://sensorML.com/def/property/electricalCurrent">
                                   <swe:uom code="mA"/>
                                   <swe:value>20 40</swe:value>
                              </swe:QuantityRange>
                         </swe:field>
                    </swe:DataRecord>
               </sml:characteristic>
 
          </sml:CharacteristicList>
     </sml:characteristics>
====

 
===== Contacts

The contacts property and the ContactList element are XML Schema implementations of the UML classes defined in clause 7.2.2.11. The contacts property takes a ContactList as its value. The ContactList member property supports an ISO 19115 CI_ResponsibleParty as its value, which is encoded according to ISO19139 schema.

The XML snippet for the ContactList element and its corresponding complex types is shown below:

[source,xml]
====
     <element name="ContactList" type="sml:ContactListType" substitutionGroup="sml:AbstractMetadataList"/>
 
     <complexType name="ContactListType">
          <complexContent>
               <extension base="sml:AbstractMetadataListType">
                    <sequence>
                         <element name="contact" type="gmd:CI_ResponsibleParty_PropertyType" minOccurs="1" maxOccurs="unbounded"/>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="ContactListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:ContactList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
==== 

A contact can have multiple roles for which it is responsible. What is of most interest in this standard is the role the responsible party plays relative to the object being described. Therefore, the role of the responsible party (e.g., manufacturer, expert, owner, etc.) shall be given by the xlink:arcrole attribute in the member property of the ContactList.

include::requirements/xml/coreProcess/requirement11.adoc[]

An example of a ContactList is shown below (note that the gmd schema requires a CharacterString element before the values of properties).

[source,xml]
====
   <sml:contacts>
      <sml:ContactList>
 
         <sml:contact xlink:arcrole="http://sensorml.com/def/role/Operator">
            <gmd:CI_ResponsibleParty>
               <gmd:organisationName>
     <gco:CharacterString>METEO France</gco:CharacterString>
               </gmd:organisationName>
               <gmd:contactInfo>
     <gmd:CI_Contact>
        <gmd:phone>
           <gmd:CI_Telephone>
              <gmd:voice>
                              <gco:CharacterString>+33 5 99 11 22 33 44</gco:CharacterString>
              </gmd:voice>
           </gmd:CI_Telephone>
        </gmd:phone>
        <gmd:address>
           <gmd:CI_Address>
              <gmd:deliveryPoint>
                 <gco:CharacterString>42 Avenue Gaspard Coriolis</gco:CharacterString>
              </gmd:deliveryPoint>
              <gmd:city>
                              <gco:CharacterString>TOULOUSE</gco:CharacterString>
              </gmd:city>
              <gmd:postalCode>
                 <gco:CharacterString>31100</gco:CharacterString>
                           </gmd:postalCode>
              <gmd:country>
                 <gco:CharacterString>FRANCE</gco:CharacterString>
              </gmd:country>
           </gmd:CI_Address>
        </gmd:address>
     </gmd:CI_Contact>
               </gmd:contactInfo>
               <gmd:role gco:nilReason="inapplicable"/>
            </gmd:CI_ResponsibleParty>
         </sml:contact>
 
          <sml:contact
            xlink:arcrole="http://sensorml.com//def/role/manufacturer"
            xlink:href="http://www.myCompany.com/contact/company.xml"/>
 
      </sml:ContactList>
   </sml:contacts>
====

 
===== Documentation

The documentation property and the DocumentList element are XML Schema implementations of the UML classes defined in clause 7.2.2.11. The documentation property takes a DocumentList as its value. The DocumentList member property supports an ISO 19115 CI_OnlineResource as its value, which is encoded according to ISO19139 schema.

The XML snippet for the DocumentList element and its corresponding complex types is shown below:

[source,xml]
====
     <element name="DocumentList" type="sml:DocumentListType" substitutionGroup="sml:AbstractMetadataList"/>
 
     <complexType name="DocumentListType">
          <complexContent>
               <extension base="sml:AbstractMetadataListType">
                    <sequence>
                         <element name="document" type="gmd:CI_OnlineResource_PropertyType" minOccurs="1" maxOccurs="unbounded"/>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="DocumentListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:DocumentList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
==== 

An example of documentation is given below (note that the gco and gmd schema require a CharacterString element before the values of properties):

[source,xml]
====
     <documentation>
          <DocumentList>
               <document xlink:arcrole="http://sensorml.com/def/role/userManual">
                    <gmd:CI_OnlineResource>
                         <gmd:linkage>
                              <gmd:URL>http://myCompany.com/ref/2031manual.pdf</gmd:URL>
                         </gmd:linkage>
                         <gmd:name>
                              <gco:CharacterString>
                                   User Manual for Model 2031
                              </gco:CharacterString>
                         </gmd:name>
                         <gmd:description>
                              <gco:CharacterString>
                                   This document provides the complete Users Manual for the myCompany sensor model 2031.
                              </gco:CharacterString>
                         </gmd:description>
                    </gmd:CI_OnlineResource>
               </document>
 
               <document xlink:arcrole="productImage">
                    <gmd:CI_OnlineResource>
                         <gmd:linkage>
                              <gmd:URL>http://myCompany.com/ref/2031image.jpg</gmd:URL>
                         </gmd:linkage>
                         <gmd:name>
                              <gco:CharacterString>
                                   Sensor Model 2031
                              </gco:CharacterString>
                         </gmd:name>
                         <gmd:description>
                              <gco:CharacterString>
                                   This is an image of sensor model 2031.
                              </gco:CharacterString>
                         </gmd:description>
                    </gmd:CI_OnlineResource>
               </document>
                 
          </DocumentList>
</documentation>
====

 
===== History

The history property and the EventList and Event elements are XML Schema implementations of the UML classes defined in clause 7.2.2.12. The history property takes an EventList as its value. The EventList member property takes an Event as its value. The XML snippets for the EventList and Event elements and their corresponding complex types are shown below:

_EventList:_

[source,xml]
====
     <element name="EventList" type="sml:EventListType" substitutionGroup="sml:AbstractMetadataList"/>
 
     <complexType name="EventListType">
          <complexContent>
               <extension base="sml:AbstractMetadataListType">
                    <sequence>
                         <element name="event" type="sml:EventPropertyType"
minOccurs="1" maxOccurs="unbounded"/>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="EventListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:EventList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
====

_Event:_
[source,xml]
====
     <element name="Event" type="sml:EventType" substitutionGroup="swe:AbstractSWEIdentifiable">
          <annotation>
               <documentation>A time tagged Event with description and relevant property values.</documentation>
          </annotation>
     </element>
     <complexType name="EventType">
          <complexContent>
               <extension base="swe:AbstractSWEIdentifiableType">
                    <sequence>
                         <element name="keywords" type="sml:KeywordListPropertyType" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>keywords useful for discovery of the event</documentation>
                              </annotation>
                         </element>
                         <element name="identification" type="sml:IdentifierListPropertyType" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>Identifiers relevant to the event</documentation>
                              </annotation>
                         </element>
                         <element name="classification" type="sml:ClassifierListPropertyType" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>Type of event (useful for discovery)</documentation>
                              </annotation>
                         </element>
                         <element name="contacts" type="sml:ContactListPropertyType" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>Persons or parties relevant to this event</documentation>
                              </annotation>
                         </element>
                         <element name="documentation" type="sml:DocumentListPropertyType" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>Additional documentation relevant to this event</documentation>
                              </annotation>
                         </element>
                         <element name="time">
                              <annotation>
                                   <documentation>DateTime of the event</documentation>
                              </annotation>
                              <complexType>
                                   <sequence>
                                        <group ref="sml:TimeInstantOrPeriod"/>
                                   </sequence>
                              </complexType>
                         </element>
                         <element name="property" type="swe:AbstractDataComponentPropertyType" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>Properties of interest to the event (e.g., calibration values, condition category, error codes, etc)
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="configuration" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>Configuration settings adjusted during event</documentation>
                              </annotation>
                              <complexType>
                                   <sequence>
                                        <element ref="sml:AbstractSettings"/>
                                   </sequence>
                              </complexType>
                         </element>
                    </sequence>
                    <attribute name="definition" type="anyURI" use="optional"/>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="EventPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:Event"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
==== 

An example of an EventList is shown below. EventList could of course be presented inline as a value of the history property, or could be maintained externally and referenced by the xlink:href attribute of the history property.

[source,xml]
====
<sml:EventList>
  <sml:event>
    <sml:Event>
      <swe:label>Scheduled Maintenance</swe:label>
      <swe:description>
          Monthly maintenance of station exterior.&#13;-Checked electronics&#13;-Checked casing&#13;Checked power
          supply.&#13;Everything OK.
       </swe:description>
      <sml:time>
        <gml:TimePeriod gml:id="MP1">
          <gml:beginPosition>2002-03-01T10:00:00Z</gml:beginPosition>
          <gml:endPosition>2002-03-01T11:00:00Z</gml:endPosition>
        </gml:TimePeriod>
      </sml:time>
    </sml:Event>
  </sml:event>
  <sml:event>
    <sml:Event>
      <swe:label>Calibration</swe:label>
      <swe:description>Recalibration of acquisition electronics using temperature reference</swe:description>
      <sml:time>
        <gml:TimeInstant gml:id="MP2">
          <gml:timePosition>2002-03-01T18:00:00Z</gml:timePosition>
        </gml:TimeInstant>
      </sml:time>
      <sml:configuration>
        <sml:Settings>
          <sml:setEncodedValues ref="base/components/raingauge/parameters/steady-state-response">
              1,2,3,4,5 2,4,6,8,10
          </sml:setEncodedValues>
        </sml:Settings>
      </sml:configuration>
    </sml:Event>
  </sml:event>
</sml:EventList>
====

==== Abstract Process

AbstractProcessType is derived from DescribedObject and serves as the base class for all processes modelled and encoded in this specification. Thus, all processes include the metadata described above plus the elements defined in this section and its subsections.

The AbstractProcess element is an XML Schema implementation of the UML class defined in clause 7.2.3.

The XML snippet for the AbstractProcess element and its corresponding complex types is shown below. The various properties of AbstractProcess will be discussed in more detail in the following subsections.

[source,xml]
====
     <element name="AbstractProcess" type="sml:AbstractProcessType" abstract="true"
          substitutionGroup="sml:DescribedObject">
          <annotation>
               <documentation>The general base model for any process.</documentation>
          </annotation>
     </element>
     <complexType name="AbstractProcessType" abstract="true">
          <complexContent>
               <extension base="sml:DescribedObjectType">
                    <sequence>
                         <element name="typeOf" type="gml:ReferenceType" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <appinfo>
                                        <gml:targetElement>sml:AbstractProcess</gml:targetElement>
                                   </appinfo>
                                   <documentation>A reference to a base process from which this process inherits properties and constraints (e.g., original equipment manufacturer’s model description, generic equation, etc.). The uniqueID of the referenced process must be provided using the xlink:title attribute while the URL to the process description must be provided by the xlink:href attribute.
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="configuration" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>Value settings that further constrain the properties of the base process.
                                   </documentation>
                              </annotation>
                              <complexType>
                                   <sequence>
                                        <element ref="sml:AbstractSettings"/>
                                   </sequence>
                              </complexType>
                         </element>
                         <element name="featuresOfInterest" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>A collection of features relevant to a process (e.g., the Gulf of Mexico, the White House the set of all Fibonacci Numbers, etc.); can also support a sampling feature. The primary purpose of the Features of Interest is to support discovery.
                                   </documentation>
                              </annotation>
                              <complexType>
                                   <sequence>
                                        <element ref="sml:FeatureList"/>
                                   </sequence>
                              </complexType>
                         </element>
                         <element name="inputs" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>The list of data components (and their properties and semantics) that the process will accept as input; In the standard linear equation y=mx+b; x is the input, m and b are the parameters, and y is the output.
                                   </documentation>
                              </annotation>
                              <complexType>
                                   <sequence>
                                        <element ref="sml:InputList"/>
                                   </sequence>
                              </complexType>
                         </element>
                         <element name="outputs" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>The list of data components (and their properties and semantics) that the process will accept as output; In the standard linear equation y=mx+b; x is the input, m and b are the parameters, and y is the output.
                                   </documentation>
                              </annotation>
                              <complexType>
                                   <sequence>
                                        <element ref="sml:OutputList"/>
                                   </sequence>
                              </complexType>
                         </element>
                         <element name="parameters" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>The list of data components (and their properties and semantics) that the process will accept as parameters; In the standard linear equation y=mx+b; x is the input, m and b are the parameters, and y is the output.
                                   </documentation>
                              </annotation>
                              <complexType>
                                   <sequence>
                                        <element ref="sml:ParameterList"/>
                                   </sequence>
                              </complexType>
                         </element>
                         <element name="modes" minOccurs="0" maxOccurs="unbounded">
                              <annotation>
                                   <documentation>A collection of parameters that can be set at once through the selection of a particular predefined mode.
                                   </documentation>
                              </annotation>
                              <complexType>
                                   <sequence>
                                        <element ref="sml:AbstractModes"/>
                                   </sequence>
                              </complexType>
                         </element>
                    </sequence>
                    <attribute name="definition" type="anyURI">
                         <annotation>
                              <documentation>An optional property that allows one to reference the process instance in an online ontology or dictionary. The value of the property must be a resolvable URI.
                              </documentation>
                         </annotation>
                    </attribute>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="AbstractProcessPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:AbstractProcess"/>
          </sequence>
          <attributeGroup ref="gml:AssociationAttributeGroup"/>
          <attributeGroup ref="gml:OwnershipAttributeGroup"/>
     </complexType>
====

 
===== Definition

As with the definition attribute used in SWE Common simple and aggregate data components, the definition attribute for a DescribedObject provides the ability to link to a definition or classification within an online ontology.  Relationships of this object with various other objects can then be inferred based on the ontology. There is some potential for overlap of functionality between the definition attribute and the identification and classification properties. Some communities may prefer to primarily use classification and identification elements, while others prefer to use the definition attribute or both.

===== TypeOf

The typeOf property provides a reference to a base process from which this process inherits properties and constraints. It is a key component in support of inheritance as described in the models in Clause 7.2.3.3.

Two pieces of information required in order to reference a base process instance, the uniqueID of the process and a resolvable URL reference to the process description. These shall be provided by the xlink:title and xlink:href attributes, respectively.

include::requirements/xml/coreProcess/requirement12.adoc[]

 

An example of the typeOf property is given below:

[source,xml]
====
   <sml:typeOf xlink:title="urn:heath:2070"
        xlink:href="http://www.sensors.ws/examples/sensorML-2.1/configuration/gamma2070.xml"/>
====

 
===== Abstract Configuration

The optional configuration property takes an AbstractConfiguration as its value, which provides a placeholder for configuration information in the AbstractProcess. A concrete class supporting configuration will be provided in a higher-level conformance class in Requirements Class: Configurable Process Schema in Clause 8.6.

===== FeatureOfInterest

The featureOfInterest property and the FeatureList element are XML Schema implementations of the UML classes defined in clause 7.2.3.1. The featureOfInterest property takes a FeatureList as its value. The FeatureList member property takes any object derived from GML AbstractFeature as its value. This feature can be described inline, but will most often be provided by reference using the xlink:href attribute.

The XML snippet for the FeatureList element and its corresponding complex types is shown below.

[source,xml]
====
     <element name="FeatureList" type="sml:FeatureListType" substitutionGroup="sml:AbstractMetadataList"/>
 
     <complexType name="FeatureListType">
          <complexContent>
               <extension base="sml:AbstractMetadataListType">
                    <sequence>
                         <element name="feature" type="gml:FeaturePropertyType" minOccurs="1" maxOccurs="unbounded"/>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="FeatureListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:FeatureList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
==== 

An example for a Feature-of-Interest list is given below. In this case, all features are by reference.

[source,xml]
====
   <sml:featureOfInterest>
          <sml:FeatureList>
               <sml:feature xlink:arcrole="http://sensorml.com/def/property/station"
                    xlink:title="urn:myDomain:station:A209"
                    xlink:href="http://myDomain.com/features/officeA209.xml"/>
               <sml:feature xlink:arcrole="http://sensorml.com/def/property/observedFeature"
                    xlink:title="urn:mmi:features:GulfOfMexico"
                    xlink:href="http://mmi.org/features/GulfOfMexico.xml"/>
          </sml:FeatureList>
     </sml:featureOfInterest>
==== 

To better understand the role that the feature of interest plays with regard to the process, the xlink:arcrole attribute of the feature property shall be used to specify this relationship. To aid in discovery, the unique ID or name of the feature shall be provided in the xlink:title attribute if it exists.

include::requirements/xml/coreProcess/requirement13.adoc[]

===== Inputs, Outputs, and Parameters

The input, output,and parameter properties and the InputList, OutputList,and ParameterList elements are XML Schema implementations of the UML classes defined in clause 7.2.3.1. The input, output,and parameter properties takes InputList, OutputList,and ParameterList elements as their respective value. The member properties of these lists take any element of the DataComponentOrObservable Union as their value. This union and its components will be discussed in more detail in subsequent sections.

The XML snippets for the InputList, OutputList,and ParameterList elements and their corresponding complex types are shown below:

_Inputs:_

[source,xml]
====
     <element name="InputList" type="sml:InputListType" substitutionGroup="swe:AbstractSWE"/>
 
     <complexType name="InputListType">
          <complexContent>
               <extension base="swe:AbstractSWEType">
                    <sequence>
                         <element name="input" minOccurs="1" maxOccurs="unbounded">
                              <complexType>
                                   <complexContent>
                                        <extension base="sml:DataComponentOrObservablePropertyType">
                                             <attribute name="name" type="NCName" use="required"/>
                                        </extension>
                                   </complexContent>
                              </complexType>
                         </element>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="InputListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:InputList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
==== 

_Outputs:

[source,xml]
====
     <element name="OutputList" type="sml:OutputListType" substitutionGroup="swe:AbstractSWE"/>
 
     <complexType name="OutputListType">
          <complexContent>
               <extension base="swe:AbstractSWEType">
                    <sequence>
                         <element name="output" minOccurs="1" maxOccurs="unbounded">
                              <complexType>
                                   <complexContent>
                                        <extension base="sml:DataComponentOrObservablePropertyType">
                                             <attribute name="name" type="NCName" use="required"/>
                                        </extension>
                                   </complexContent>
                              </complexType>
                         </element>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="OutputListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:OutputList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
==== 

_Parameters:_

[source,xml]
====
     <element name="ParameterList" type="sml:ParameterListType" substitutionGroup="swe:AbstractSWE"/>
 
     <complexType name="ParameterListType">
          <complexContent>
               <extension base="swe:AbstractSWEType">
                    <sequence>
                         <element name="parameter" minOccurs="1" maxOccurs="unbounded">
                              <complexType>
                                   <complexContent>
                                        <extension base="sml:DataComponentOrObservablePropertyType">
                                             <attribute name="name" type="NCName" use="required"/>
                                        </extension>
                                   </complexContent>
                              </complexType>
                         </element>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="ParameterListPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:ParameterList"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
====

 

An example of inputs, outputs, and parameters from a particular process is given below (in this case, a gamma radiation sensor):

[source,xml]
====
     <!– =================== –>
     <!–   Inputs               –>
     <!– =================== –>
     <sml:inputs>
          <sml:InputList>
               <sml:input name="gammaRadiation">
                    <sml:ObservableProperty definition="http://sensorML.com/def/property/radiation">
                         <swe:label>Electromagnetic Radiation</swe:label>
                    </sml:ObservableProperty>
               </sml:input>
          </sml:InputList>
     </sml:inputs>
     <!– ===================== –>
     <!–     outputs     –>
     <!– ===================== –>
     <sml:outputs>
          <sml:OutputList>
               <sml:output name="dose">
                    <swe:DataRecord>
                         <swe:field name="averageDose">
                              <swe:Quantity definition="http://sensors.ws/ont/SWE/sensor-property/DoseRate.html">
                                   <swe:label>Average Dose of Gamma Radiation</swe:label>
                                   <swe:uom code="uR/min"/>
                              </swe:Quantity>
                         </swe:field>
                         <swe:field name="InstantaneousDose">
                              <swe:Quantity definition="http://sensorML.com/def/property/radiationDose">
                                   <swe:label>Instantaneous Dose of Gamma Radiation</swe:label>
                                   <swe:uom code="uR"/>
                              </swe:Quantity>
                         </swe:field>
                    </swe:DataRecord>
               </sml:output>
          </sml:OutputList>
     </sml:outputs>
     <!– ======================== –>
     <!–        Parameters                 –>
     <!– ======================== –>
     <sml:parameters>
          <sml:ParameterList>
               <sml:parameter name="energyResponse">
                    <swe:DataArray definition="http://sensors.ws/spectralResponse">
                         <swe:label>Gamma Radiation Response Curve</swe:label>
                         <swe:description>
                              The normalized energy response per KeV showing the sensitivity to gamma radiation
                         </swe:description>
                         <swe:elementCount>
                              <swe:Count>
                                   <swe:value>7</swe:value>
                              </swe:Count>
                         </swe:elementCount>
                         <swe:elementType name="energyResponse">
                              <swe:DataRecord>
                                   <swe:label>Normalize Energy Response</swe:label>
                                   <swe:field name="radiationEnergy">
                                        <swe:Quantity definition="http://sensorml.com/def/propertyradiationEnergy">
                                             <swe:label>Radiation Energy</swe:label>
                                             <swe:uom code="KeV"/>
                                        </swe:Quantity>
                                   </swe:field>
                                   <swe:field name="relativeResponse">
                                        <swe:Quantity definition="http://sensorml.com/def/propertyrelativeResponse">
                                             <swe:label>Relative Response</swe:label>
                                             <swe:uom code="%"/>
                                        </swe:Quantity>
                                   </swe:field>
                              </swe:DataRecord>
                         </swe:elementType>
                         <swe:encoding>
                              <swe:TextEncoding blockSeparator="&#10;" tokenSeparator=","/>
                         </swe:encoding>
                         <swe:values>
                              10.0,73 17.5,89.5 20.0,94.0 30.,95.5 40.0,96.0 50.0,96.0 100.0,94.0
                         </swe:values>
                    </swe:DataArray>
               </sml:parameter>
          </sml:ParameterList>
     </sml:parameters>
====

 
====== Data Component Union

The DataComponentOrObservable group provides three choices to serve as process inputs, outputs, and parameters. These include swe:AbstractDataComponent, sml:ObservableProperty, and sml:DataInterface. These will each be discussed further in the following sections.

The XML snippet defining the DataComponentOrObservable group is given below:

[source,xml]
====
     <group name="DataComponentOrObservable">
          <choice>
               <element ref="swe:AbstractDataComponent">
                    <annotation>
                         <documentation>A single digital number (DN) or aggregate of DNs that represent the value of some property. Single data components can be of type Quantity, Count, Category, Boolean, Text, or Time; these can be aggregated in records, arrays, vector, and matrices. 
                         </documentation>
                    </annotation>
               </element>
               <element ref="sml:ObservableProperty">
                    <annotation>
                         <documentation>A physical property of the environment that can be observed by an appropriate detector (e.g.,temperature, pressure, etc.); Typically,an ObservableProperty serves as the input of a detector and the output of an actuator.
                         </documentation>
                    </annotation>
               </element>
               <element ref="sml:DataInterface">
                    <annotation>
                         <documentation>A data interface serves as an intermediary between the pure digital domain and the physical domain where DN are encoded into a format and perhaps transmitted through physical connections using some well-defined protocol. The DataInterface element allows one to define the components, semantics, encoding, connections, and protocol at an input, output, or parameter port.
                         </documentation>
                    </annotation>
               </element>
          </choice>
     </group>
 
     <complexType name="DataComponentOrObservablePropertyType">
          <sequence minOccurs="0">
               <group ref="sml:DataComponentOrObservable"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
====

======  ObservableProperty

The ObservableProperty element is an XML encoding of the model defined in Clause 7.2.1 and discussed more in Clause 7.2.3.1. The ObservableProperty is used to represent an observable property or state in the environment. It is often used as an input field (e.g., stimulus) for a detector or the output field (e.g., action) of an actuator.

The XML snippet defining ObservableProperty and its associated complex types is shown below:

[source,xml]
====
     <element name="ObservableProperty" type="sml:ObservablePropertyType"
          substitutionGroup="swe:AbstractSWEIdentifiable">
          <annotation>
               <documentation>A physical property that can be observed and possibly measured (e.g., temperature, color, position). An ObservableProperty has unambiguous definition, but does not have units of measure.
               </documentation>
          </annotation>
     </element>
 
     <complexType name="ObservablePropertyType">
          <complexContent>
               <extension base="swe:AbstractSWEIdentifiableType">
                    <attribute name="definition" type="anyURI" use="required"/>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="ObservablePropertyPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:ObservableProperty"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
====

The ObservableProperty element requires a URL as the value of its definition attribute, which shall resolve to a definition for the observable within an online dictionary or ontology.

include::requirements/xml/coreProcess/requirement14.adoc[]

An minimal example of the use of ObservableProperty as a value for an input property is given below:

[source,xml]
====
     <sml:input name="temperature">
          <sml:ObservableProperty
               definition="http://www.opengis.net/def/property/OGC/0/AtmosphericTemperature"/>
     </sml:input>
====

 
====== SWE Common Data

SWE Common data types support the description and encoding of determined values, those measured or calculated by a physical or computational process. In addition to the those properties described in ObservableProperty, SWE Common data types can also support other properties such as units of measure, constraints, quality indicators, and values. It is highly recommended that one become familiar with the SWE Common Data specification in OGC 08-094.

In addition to simple data types such as Quantity, Count, Boolean, Category, Time, and Text, SWE Common Data also supports several aggregate data types, such as DataRecord, DataArray, Vector, and Matrix. These allow appropriate grouping of data components, such as a DataRecord including an instantaneous snapshot of the atmosphere (e.g., temperature, pressure, wind direction, and wind speed), a DataArray providing the axes definitions and values for a calibration curve, a Vector providing the GPS location (e.g., latitude, longitude, and altitude) of a dynamic platform, or a Matrix providing the covariance of a set of measurements.

include::requirements/xml/coreProcess/requirement15.adoc[]

The following example for a wind chill calculation process uses only SWE Common Quantity elements for inputs and outputs. Note that the input fields are surrounded by a swe:DataRecord element since the temperature and wind speed fields express the condition of the environment at a given time instance.

[source,xml]
====
    <!–================ –>
    <!–             Inputs            –>
    <!– ================ –>
    <sml:inputs>
        <sml:InputList>
            <sml:input name="process_inputs">
                <swe:DataRecord>
       <swe:field name="temperature">
           <swe:Quantity definition="http://sweet.jpl.nasa.gov/2.2/quanTemperature.owl#Temperature">
                            <swe:uom code="cel"/>
           </swe:Quantity>
       </swe:field>
       <swe:field name="windSpeed">
           <swe:Quantity definition="http://sweet.jpl.nasa.gov/2.2/quanSpeed.owl#WindSpeed">
               <swe:uom code="m/s"/>
           </swe:Quantity>
       </swe:field>
                </swe:DataRecord>          
            </sml:input>
        </sml:InputList>   
    </sml:inputs>
    <!– ================ –>
    <!–            Outputs            –>
    <!– ================ –>
    <sml:outputs>
        <sml:OutputList>
            <sml:output name="windChill">
                <swe:Quantity definition="http://sweet.jpl.nasa.gov/2.2/quanTemperature.owl#WindChill">
       <swe:uom code="cel"/>
                </swe:Quantity>
            </sml:output>
        </sml:OutputList>     
    </sml:outputs>
====

include::requirements/xml/coreProcess/requirement16.adoc[]

An example of position output provided as output of a system is given below. This example uses both Vector and DataRecord elements to group the fields appropriately.

[source,xml]
====
<sml:output>
      <swe:DataRecord>
         <swe:field name="location">
            <swe:Vector
                      definition="http://sensorml.com/def/property/SensorLocation"
               referenceFrame="http://www.opengis.net/def/crs/EPSG/6.7/4979"
               localFrame="#SENSOR_FRAME">
               <swe:coordinate name="Lat">
     <swe:Quantity definition="http://sensorml.com/def/property/latitude" axisID="Lat">
        <swe:uom code="deg"/>
     </swe:Quantity>
               </swe:coordinate>
               <swe:coordinate name="Lon">
     <swe:Quantity definition="http://sensorml.com/def/property/longitude" axisID="Long">
        <swe:uom code="deg"/>
     </swe:Quantity>
               </swe:coordinate>
               <swe:coordinate name="Alt">
     <swe:Quantity definition="http://sensorml.com/def/property/altitude" axisID="Alt">
        <swe:uom code="m"/>
     </swe:Quantity>
               </swe:coordinate>
            </swe:Vector>
         </swe:field>
         <swe:field name="orientation">
            <swe:Vector
                      definition="http://sensorml.com/def/property/SensorOrientation"
               referenceFrame="http://www.opengis.net/def/crs/NED"
               localFrame="#SENSOR_FRAME">
               <swe:coordinate name="TrueHeading">
     <swe:Quantity definition="http://sensorml.com/def/property/trueHeading" axisID="Z">
        <swe:uom code="deg"/>
     </swe:Quantity>
               </swe:coordinate>
               <swe:coordinate name="Pitch">
     <swe:Quantity definition="http://sensorml.com/def/property/pitch" axisID="Y">
        <swe:uom code="deg"/>
     </swe:Quantity>
               </swe:coordinate>
            </swe:Vector>
         </swe:field>
      </swe:DataRecord>
   </sml:output>  
====

 
======  Data Interface

The DataInterface element is an XML encoding of the model defined in Clause 7.10. DataInterface describes the data components as described in the previous clause, but also provides a description of the data encoding of a datastream flowing to or from a process interface as well as a description of interface characteristics itself (e.g., the communication protocols and perhaps physical nature as outlined in the OSI interface stack).

The XML snippet for the DataInterface element and its associated complex types is shown below:

[source,xml]
====
     <element name="DataInterface" type="sml:DataInterfaceType" substitutionGroup="swe:AbstractSWEIdentifiable">
          <annotation>
               <documentation>The DataInterface description provides information sufficient for “plug-and-play” access to and parsing of the data stream or file at the particular IO port.
               </documentation>
          </annotation>
     </element>
 
     <complexType name="DataInterfaceType">
          <complexContent>
               <extension base="swe:AbstractSWEIdentifiableType">
                    <sequence>
                         <element name="data" type="swe:DataStreamPropertyType">
                              <annotation>
                                   <documentation>The definition of the digital data components and encoding accessed through the data interface.
                                   </documentation>
                              </annotation>
                         </element>
                         <element name="interfaceParameters" type="swe:DataRecordPropertyType" minOccurs="0" maxOccurs="1">
                              <annotation>
                                   <documentation>A set of property values that define the type and configuration of a data interface (e.g., the port settings of an RS232 interface).
                                   </documentation>
                              </annotation>
                         </element>
                    </sequence>
               </extension>
          </complexContent>
     </complexType>
 
     <complexType name="DataInterfacePropertyType">
          <sequence minOccurs="0">
               <element ref="sml:DataInterface"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
====

The DataInterface essentially consists of a required data property, which takes a SWE Common DataStream element as its value, and an optional interfaceParameters property that defines the interface as a set of fields within a SWE Common DataRecord. This specification does not define the specific fields required to define the interface, but it is expected that one or more profiles will be defined for common interface definitions.

In the following example, the values property reference a RESTful resource (e.g., a daily record of weather) available on the web through html protocol. This example is for a network of weather sensors; thus the network stream includes station ID and location as part of the data components. In this case, a description of the InterfaceParameters is neither required nor useful.

[source,xml]
====
   <sml:outputs>
      <sml:OutputList>
         <sml:output name="sensorNetworkStream">
            <sml:DataInterface>
               <sml:data>
     <swe:DataStream>
                    <swe:description>
                          This stream is for a sensor network where all output are homogeneous;
                          The station ID and location is provided with each reading;
                     </swe:description>
        <swe:elementType name="weather_data">
           <swe:DataRecord>
                           <swe:label>Atmospheric Conditions</swe:label>
              <swe:field name="time">
                 <swe:Time
                    definition="http://sensorml.com/def/property/SamplingTime">
                    <swe:uom
          xlink:href="http://www.opengis.net/def/uom/ISO-8601/0/Gregorian"/>
                 </swe:Time>
              </swe:field>
              <swe:field name="sensorID">
                 <swe:Text
                    definition="http://www.opengis.net/def/property//OGC/0/sensorUID"/>
              </swe:field>
 
              <swe:field name="location">
                 <swe:Vector
                    definition="http://sensorml.com/def/property/PlatformLocation"
                    referenceFrame="http://www.opengis.net/def/crs/EPSG/0/4979">
                    <swe:coordinate name="lat">
          <swe:Quantity
             definition="http://sweet.jpl.nasa.gov/2.0/spaceCoordinates.owl#Latitude"
                          axisID="Lat">
             <swe:uom code="deg"/>
          </swe:Quantity>
                    </swe:coordinate>
                    <swe:coordinate name="lon">
          <swe:Quantity
             definition="http://sweet.jpl.nasa.gov/2.0/spaceCoordinates.owl#Longitude"
             axisID="Long">
             <swe:uom code="deg"/>
          </swe:Quantity>
                    </swe:coordinate>
                    <swe:coordinate name="alt">
          <swe:Quantity
             definition="http://sweet.jpl.nasa.gov/2.0/spaceExtent.owl#Altitude"
             axisID="h">
             <swe:uom code="m"/>
          </swe:Quantity>
                    </swe:coordinate>
                 </swe:Vector>
              </swe:field>
 
              <swe:field name="temp">
                              <swe:Quantity
                    definition="http://mmisw.org/ont/cf/parameter/air_temperature">
                    <swe:uom code="Cel"/>
                 </swe:Quantity>
              </swe:field>
              <swe:field name="pressure">
                 <swe:Quantity
                    definition="http://mmisw.org/ont/cf/parameter/barometric_pressure">
                    <swe:uom code="kPa"/>
                 </swe:Quantity>
              </swe:field>
              <swe:field name="wind_speed">
                              <swe:Quantity
                    definition="http://mmisw.org/ont/cf/parameter/wind_speed">
                    <swe:uom code="km/h"/>
                 </swe:Quantity>
              </swe:field>
              <swe:field name="wind_dir">
                 <swe:Quantity
                    definition="http://mmisw.org/ont/cf/parameter/wind_to_direction">
                    <swe:uom code="deg"/>
                 </swe:Quantity>
              </swe:field>
           </swe:DataRecord>
        </swe:elementType>
        <swe:encoding>
                        <swe:TextEncoding tokenSeparator="," blockSeparator=“”/>
        </swe:encoding>
 
        <swe:values xlink:href="rtp://mySensors.com:4356/76455"/>
 
     </swe:DataStream>
               </sml:data>
            </sml:DataInterface>
         </sml:output>
====

The returned resource “weatherNetwork201.txt” might return the most recent reading from the network and look like:

`2009-05-23T19:36:15Z,urn:myNet:stations:76455,35.4,135.6,5.0,25.4,100.3,7.31,270.8`

`2009-05-23T19:36:15Z,urn:myNet:stations:55577,34.1,138.9,4.1,25.5,100.5,7.54,271.4`

`2009-05-23T19:38:15Z,urn:myNet:stations:85643,43.9,141.0,3.8,25.7,100.1,7.44,260.2`

`2009-05-23T19:39:15Z,urn:myNet:stations:22298,46.7,140.0,1.2,26.5,100.6,7.30,271.9`

`2009-05-23T19:40:15Z,urn:myNet:stations:92675,43.1,131.0,6.7,25.5,100.2,7.54,271.0`

The following example also references an external source for the values of the stream, but instead of a static resource, it references a Real-Time-Protocol (RTP) server that will continue to send real-time measurements until the client disconnects.

[source,xml]
====
         <sml:output name="gammaRadiation">
            <sml:DataInterface>
 
               <!– data description –>
               <sml:data>
     <swe:DataStream>
        <swe:elementType name="gamaRadiation">
                    <swe:DataRecord>
                         <swe:field name="averageDose">
                              <swe:Quantity definition="http://sensorml.com/def/property/DoseRate.html">
                                   <swe:label>Average Dose of Gamma Radiation</swe:label>
                                   <swe:uom code="uR/min"/>
                              </swe:Quantity>
                         </swe:field>
                         <swe:field name="InstantaneousDose">
                              <swe:Quantity definition="http://sensorml.com/def/property/radiationDose">
                                   <swe:label>Instantaneous Dose of Gamma Radiation</swe:label>
                                   <swe:uom code="uR"/>
                              </swe:Quantity>
                         </swe:field>
                    </swe:DataRecord>
        </swe:elementType>
 
        <!– encoding description –>
        <swe:encoding>
           <swe:TextEncoding tokenSeparator="," blockSeparator=" "/>
        </swe:encoding>
                     
        <!– a Real-Time-Protocol (RTP) server that continues to stream real time measurements –>
        <swe:values xlink:href="rtp://myServer.com:4563/sensor/02080"/>
 
     </swe:DataStream>
               </sml:data>
            </sml:DataInterface>
         </sml:output>
====

Once one establishes connection to such a server, the server would then begin streaming over real-time values for the data as they become available. Such a stream might look like:

 
`7248,26.3 7248,26.4 7250,26.6 7251,28.3` …   [continues until disconnected]

Since SWE Common also supports binary encodings, the same sensor system could describe binary data, as in the current example:

[source,xml]
====
         <sml:output name="gammaRadiation">
            <sml:DataInterface>
 
               <!– data description –>
               <sml:data>
     <swe:DataStream>
        <swe:elementType name="gamaRadiation">
                    <swe:DataRecord>
                         <swe:field name="averageDose">
                              <swe:Quantity definition="http://sensorml.com/def/property/DoseRate.html">
                                   <swe:label>Average Dose of Gamma Radiation</swe:label>
                                   <swe:uom code="uR/min"/>
                              </swe:Quantity>
                         </swe:field>
                         <swe:field name="InstantaneousDose">
                              <swe:Quantity definition="http://sensorml.com/def/property/radiationDose">
                                   <swe:label>Instantaneous Dose of Gamma Radiation</swe:label>
                                   <swe:uom code="uR"/>
                              </swe:Quantity>
                         </swe:field>
                    </swe:DataRecord>
        </swe:elementType>
 
               <swe:encoding>
                    <swe:BinaryEncoding byteEncoding="raw" byteOrder="bigEndian">
                         <swe:member>
                              <swe:Component ref="averageDose"
                                   dataType="http://www.opengis.net/def/dataType/OGC/0/float32"/>
                         </swe:member>
                         <swe:member>
                              <swe:Component ref="instantaneousDose"
                                   dataType="http://www.opengis.net/def/dataType/OGC/0/float32"/>
                         </swe:member>
                    </swe:BinaryEncoding>           
               </swe:encoding>
 
       <swe:values xlink:href="rtp://myServer.com:4563/sensor/02080"/>
 
                 </swe:DataStream>
              </sml:data>
           </sml:DataInterface>
       </sml:output>
==== 

include::requirements/xml/coreProcess/requirement17.adoc[]

Using the SWE Common Data element, DataChoice, it is also possible to define and stream a collection of disparate packets within the same DataStream. According to the SWE Common Data specification, the structure of each packet shall be defined as a separate item within the DataChoice object. The subsequent values of each packet shall  be preceded by the item name, as in the example XML and data stream below:

[source,xml]
====
        <sml:output name="tempAndWind">
            <sml:DataInterface>
               <sml:data>
     <swe:DataStream>
        <swe:elementType name="message">
           <swe:DataChoice>
 
              <!– packet definition 1 - temperature –>
              <swe:item name="TEMP">
                 <swe:DataRecord>
                    <swe:label>Temperature Measurement</swe:label>
                    <swe:field name="time">
          <swe:Time definition="http://sensorml.com/def/property/SamplingTime">
             <swe:uom  xlink:href="http://www.opengis.net/def/uom/ISO-8601/0/Gregorian"/>
          </swe:Time>
                    </swe:field>
                    <swe:field name="temp">
          <swe:Quantity definition="http://mmisw.org/ont/cf/parameter/air_temperature">
             <swe:uom code="Cel"/>
          </swe:Quantity>
                    </swe:field>
                 </swe:DataRecord>
              </swe:item>
 
              <!– packet definition 2 - wind –>
              <swe:item name="WIND">
                 <swe:DataRecord>
                    <swe:label>Wind Measurement</swe:label>
                    <swe:field name="time">
          <swe:Time  definition="http://sensorml.com/def/property/SamplingTime">
             <swe:uom xlink:href="http://www.opengis.net/def/uom/ISO-8601/0/Gregorian"/>
          </swe:Time>
                    </swe:field>
                    <swe:field name="wind_speed">
          <swe:Quantity definition="http://mmisw.org/ont/cf/parameter/wind_speed">
             <swe:uom code="km/h"/>
                       </swe:Quantity>
                    </swe:field>
                    <swe:field name="wind_dir">
          <swe:Quantity definition="http://mmisw.org/ont/cf/parameter/wind_to_direction">
                                       <swe:uom code="deg"/>
          </swe:Quantity>
                    </swe:field>
                 </swe:DataRecord>
              </swe:item>
                        </swe:DataChoice>
        </swe:elementType>
 
        <swe:encoding>
           <swe:TextEncoding tokenSeparator="," blockSeparator=“”/>
        </swe:encoding>
 
        <swe:values xlink:href="rtp://mySensors.com:4356/76455"/>
 
     </swe:DataStream>
               </sml:data>
            </sml:DataInterface>
         </sml:output>
==== 

With an example streaming values looking like:

`TEMP,2009-05-23T19:36:15Z,25.5`

`TEMP,2009-05-23T19:37:15Z,25.6`

`WIND,2009-05-23T19:37:17Z,56.3,226.3`

`TEMP,2009-05-23T19:38:15Z,25.5`

`WIND,2009-05-23T19:38:16Z,58.4,225.1` 

include::requirements/xml/coreProcess/requirement18.adoc[]

In addition to online interfaces to data, DataInterface can also support physical interfaces such as RS232 or USB. In such cases, the value property is ignored, and the interfaceParameters property of the DataInterface element shall be used to specify the interface characteristics.

An example of an interface description is given below. Since interface description profiles will be created under separate documents, the following example is informative, not normative.

[source,xml]
====
              <sml:interfaceParameters>
               <swe:DataRecord definition="http://sensorml.com/def/property/serialPortSettings">
                    <swe:field name="portType">
                         <swe:Category definition="http://sensorml.com/def/property/serialPortType">
                              <swe:label>Port Type</swe:label>
                              <swe:value>RS232</swe:value>
                         </swe:Category>
                    </swe:field>
                    <swe:field name="portNumber">
                         <swe:Count definition="http://sensorml.com/def/property/portNumber">
                              <swe:label>Port Number</swe:label>
                              <swe:value>0</swe:value>
                         </swe:Count>
                    </swe:field>
                    <swe:field name="baudRate">
                         <swe:Count definition="http://sensorml.com/def/property/baudRate">
                              <swe:label>Baud Rate</swe:label>
                              <swe:value>9600</swe:value>
                         </swe:Count>
                    </swe:field>
                    <swe:field name="bits">
                         <swe:Count definition="http://sensorml.com/def/property/DataBitSize">
                              <swe:label>Data Bits</swe:label>
                              <swe:value>8</swe:value>
                         </swe:Count>
                    </swe:field>
                    <swe:field name="parity">
                         <swe:Category definition="http://sensorml.com/def/property/baudRate">
                              <swe:label>Parity</swe:label>
                              <swe:value>N</swe:value>
                         </swe:Category>
                    </swe:field>
                    <swe:field name="stopBits">
                         <swe:Count definition="http://sensorml.com/def/property/stopBits">
                              <swe:label>Stop Bits</swe:label>
                              <swe:value>1</swe:value>
                         </swe:Count>
                    </swe:field>
               </swe:DataRecord>
               </sml:interfaceParameters>
====
 
===== Modes

The AbstractModes element provides a base class from which will be derived a concrete Modes class in the higher-level conformance class specified by the Requirements Class: Configurable Process Schema in Clause 8.6.

The XML Schema implementation of AbstractModes and its related complex type is given below:

[source,xml]
====
     <element name="AbstractModes" type="sml:AbstractModesType" substitutionGroup="swe:AbstractSWE"/>
 
     <complexType name="AbstractModesType">
          <complexContent>
               <extension base="swe:AbstractSWEType"/>
          </complexContent>
     </complexType>
 
     <complexType name="AbstractModesPropertyType">
          <sequence minOccurs="0">
               <element ref="sml:AbstractModes"/>
          </sequence>
          <attributeGroup ref="swe:AssociationAttributeGroup"/>
     </complexType>
====